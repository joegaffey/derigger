<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>De Rigger</title>
    <style>
      body {
        margin: 0;
        font-family: verdana;
      }
      .loader {       
        font-size: 24px;
        display: none;
        height: auto;
        width: 250px;
        position: absolute;
        top: calc(50% - 50px);
        left: calc(50% - 125px);
        text-align: center;
        padding: 30px 0;
        background-color: #222222;
        color: lightgray;
      }
      .ta-container {
        position: absolute;
        display: flex;
        flex-direction: column;
        top: 20px;
        left: 20px;
      }
      .ta-buttons {
        display: flex;
        flex-direction: row;
        margin: 2px;
      }
      .ta-buttons > * {
        margin: 2px;
        user-select: none;
      }
      #ta {
        font-size: 12px;
      }
    </style>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "three": "./lib/three.module.js",
          "orbitControls": "./lib/OrbitControls.js",
          "vrButton": "./lib/VRButton.js",
          "stlProfile": "./STLProfile.js"
        }
      }      
    </script>
    <script type="text/javascript" src="./lib/dat.gui.min.js"></script>
  </head>
  <body>
    <div class="loader">
      Loading...
    </div>
    <div class="ta-container">
      <div class="ta-buttons">
        <button id="helpButton">Help</button>
        <button id="listButton">Part List</button>   
      </div>
<textarea id="ta" rows="10" cols="43">
8040, 1, 1, 1000, -40, -40, -500, 0, 0, 90
8040, 1, 1, 1000, 500, -40, -500, 0, 0, 90
4040, 1, 1, 500, -40, 0, -480, 0, 90, 90
8040, 1, 1, 500, -40, -40, 100, 0, 90, 90
8040, 1, 1, 500, -40, -40, 460, 0, 90, 90
8040, 1, 1, 550, -40, 590, -200, 90, 0, 90
8040, 1, 1, 550, 500, 590, -200, 90, 0, 90
8040, 1, 1, 500, -40, 540, -200, 90, 90, 90
4040, 1, 1, 400, 40, 80, 100, 0, 0, 90
4040, 1, 1, 400, 380, 80, 100, 0, 0, 90
c4040, 1, 1, 1, 360, 40, 100, 0, 0, 90
c4040, 1, 1, 1, 60, 40, 100, 0, 0, 0
c4040, 1, 1, 1, 360, 40, 460, 0, 0, 90
c4040, 1, 1, 1, 60, 40, 460, 0, 0, 0
c4040, 1, 1, 1, -40, 40, -120, 0, -90, 0
c4040, 1, 1, 1, 500, 40, -120, 0, -90, 0
c4040, 1, 1, 1, 460, 40, -200, 0, 90, 0
c4040, 1, 1, 1, -80, 40, -200, 0, 90, 0
c8040, 1, 1, 1, -40, 500, -200, 0, 0, -90
c8040, 1, 1, 1, 460, 500, -200, 0, 0, 180
c4040, 1, 1, 1, -40, 0, -460, 90, 0, 0
c4040, 1, 1, 1, 460, 0, -460, 90, 0, 90
c8040, 1, 1, 1, 460, 40, 140, 90, 0, 90
c8040, 1, 1, 1, -40, 40, 140, 90, 0, 0
c8040, 1, 1, 1, -40, 40, 460, 90, 0, -90
c8040, 1, 1, 1, 460, 40, 460, 90, 0, 180
</textarea>
    </div>
    
    <dialog id="plDialog">
      <p>Parts:</p>
      <p id="plText"></p>
      <form method="dialog">
        <button>OK</button>
      </form>
    </dialog>
    
    <dialog id="helpDialog">
      <p>Change the comma separated values in the text area.</p>
      <p>Each row represents a part:</p>
      <p>Part, x, y, z (scale), x, y, z (position), x, y, z (angle)</p>
      <p>Currently available parts:<br/>
        <ul>
          <li>"8040" - 8040 profile</li>
          <li>"4040" - 4040 profile</li>
          <li>"c8040" - 8040 angle</li>
          <li>"c4040" - 4040 angle</li>
        </ul>
      </p>
      <p>Profile models are 1mm so scale the z axis to get the desired length.</p>
      <form method="dialog">
        <button>OK</button>
      </form>
    </dialog>

    
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'orbitControls';
      import { STLLoader } from "./lib/STLLoader.js";

      // import { VRButton } from 'vrButton';

      const gui = new dat.GUI();
      gui.close();
      
      let loadingCount = 0;
      const loaderEl = document.querySelector('.loader');

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        10000
      );
      
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // renderer.xr.enabled = true;
      // document.body.appendChild(VRButton.createButton(renderer));

      const controls = new OrbitControls(camera, renderer.domElement);
      
      const wireMaterial = new THREE.MeshPhongMaterial({
        color: 0x88ff88,
        transparent: true,
        opacity: 0.2,
      });
      
      const plColor = 0xffff00;

      // prettier-ignore
      const urlParams = new URLSearchParams(window.location.hash.replace("#","?"));
      
      const camTarget = [0, 150, 0];

      const cams = {
        leftShoulder: { pos: [-250, 1000, 1200], target: camTarget },
        rightShoulder: { pos: [250, 1000, 1200], target: camTarget },
        top: { pos: [200, 2000, -200], target: [200, 0, -200] },
        driver: { pos: [200, 700, 500], target: [200, 700, 499] },        
      };
      setCamera(Object.values(cams)[0]);
      
      const pLight = new THREE.PointLight(0xffffff, 5, 1000);
      pLight.position.set(100, 100, 100);
      scene.add(pLight);


      const aLight = new THREE.AmbientLight(0x404040, 3);
      scene.add(aLight);
      
      const sceneConfig = {
        wireframe: false,
        wireMaterial: wireMaterial,
      };
      
      const sceneGUI = gui.addFolder('Scene');
      sceneGUI.add(sceneConfig, 'wireframe').name('X-Ray').onChange((value) => { setXRay(value); });;
      sceneGUI.add(sceneConfig.wireMaterial, 'opacity', 0.1, 0.5, 0.01).name('Opacity');
      sceneGUI.add(aLight, 'intensity', 0, 5, 0.01).name('Ambient Light');
      
      const pLightGUI = sceneGUI.addFolder('Point Light');
      pLightGUI.add(pLight, 'intensity', 0, 5, 0.01).name('Intensity');
      pLightGUI.add(pLight.position, 'x', -100, 100, 0.1).name('X');
      pLightGUI.add(pLight.position, 'y', -100, 100, 0.1).name('Y');
      pLightGUI.add(pLight.position, 'z', -100, 100, 0.1).name('Z');
      pLightGUI.addColor(pLight, 'color').name('Color');
      
      const camGUI = gui.addFolder('Camera');
      
      const camSelect = { view: Object.keys(cams)[0] };
      camGUI.add(camSelect, 'view', Object.keys(cams)).name('View').onChange((value) => {
        setCamera(cams[value]);
      });
      camGUI.add(camera, 'fov', 20, 120).name('FoV').onChange((value) => {
        camera.updateProjectionMatrix();
      });
      
      const camPosGUI = camGUI.addFolder('Position');
      camPosGUI.add(camera.position, 'x', -2500, 2500).name('X').listen();
      camPosGUI.add(camera.position, 'y', -2500, 2500).name('Y').listen();
      camPosGUI.add(camera.position, 'z', -2500, 2500).name('Z').listen();
      
      const camRotGUI = camGUI.addFolder('Rotation');
      camRotGUI.add(camera.rotation, 'x', -Math.PI, Math.PI).name('Z').listen();
      camRotGUI.add(camera.rotation, 'y', -Math.PI, Math.PI).name('Y').listen();
      camRotGUI.add(camera.rotation, 'z', -Math.PI, Math.PI).name('Z').listen();
      
      const plasticMaterial = new THREE.MeshPhongMaterial({
        color: 0x222222,
      });
      
      const taElement = document.querySelector('#ta');
      const helpButton = document.querySelector('#helpButton');
      const listButton = document.querySelector('#listButton');
      const plDialog = document.querySelector('#plDialog');
      const helpDialog = document.querySelector('#helpDialog');
      const plText = document.querySelector('#plText');
      
      helpButton.addEventListener('click', (event) => {
        helpDialog.showModal();
      });
      
       listButton.addEventListener('click', () => {
         let list = '';
         let nuts = 0;
         const rows = taElement.value.split('\n');
         rows.forEach(row => {
           if(row.trim().length > 0) {
             const items = row.split(',');           
             const model = models[items[0]];
             
             list += model.name;
             if(items[3] > 1)
               list += ` (${items[3].trim()}mm)`;
             list += '\n';
             if(model.nuts)
               nuts += model.nuts;
          }
        });         
         
        const counts = {};
        const pList = list.split('\n');
        pList.forEach(x => { counts[x] = (counts[x] || 0) + 1; });
        // console.log(counts)
         
        list = '';
        Object.keys(counts).forEach(i => {
          if(i.trim().length > 0)
            list += i + ' x' + counts[i] + '\n';
        });
         
        list += ' T-slot nuts and bolts x' + nuts;
         
        plText.innerText = list;
        plDialog.showModal();
      });

      taElement.onkeyup = () => {
        rebuild();
      }
      
      function rebuild() {
        for (let i = scene.children.length - 1; i >= 0; i--) {
          if(scene.children[i].type === "Mesh")
            scene.remove(scene.children[i]);
        }        
        buildRig();
      }
      
      const c4040Shape = new THREE.Shape();      
      c4040Shape.lineTo(40, 0);      
      c4040Shape.lineTo(0, 40);
      
      const c4040Geom = new THREE.ExtrudeGeometry( c4040Shape, { depth: 40, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 } );
      const c8040Geom = new THREE.ExtrudeGeometry( c4040Shape, { depth: 80, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 } );
      
      const models = {
        "8040": { name: '8040 profile', geom: null, adjust: [1,1,0.01,0,0,0,0,0,0] },   //https://www.thingiverse.com/thing:4261766
        "4040": { name: '4040 profile', geom: null, adjust: [1,1,0.01,-20,0,0,0,0,0] },  //https://www.thingiverse.com/thing:5372050
        "c4040": { name: '4040 angle', geom: c4040Geom, nuts: 2 },
        "c8040": { name: '8040 angle', geom: c8040Geom, nuts: 4 }
      };      
      
      const baseURL = 'https://cdn.glitch.global/986c5687-2972-46f0-b0ff-7b262f434b83/';
      
      const stlLoader = new STLLoader();
      
      function getGeometry(name) {
        stlLoader.load(
          `${baseURL}${name}.stl`,
          (geometry) => {
            models[name].geom = geometry;
            buildRig();
          },
          (xhr) => {
            console.log((xhr.loaded / xhr.total) * 100 + '% loaded');
          },
          (error) => {
            console.log(`Error loading profile STL: ${name}`);
          }
        );
      }
      
      Object.keys(models).forEach(model => {
        if(!models[model].geom) 
          getGeometry(model);
      });
      
      function getPart(name) {
        const part = new THREE.Mesh();
        const model = models[name];
        if(!model)
          return null;
        if(model.geom)
          part.geometry = model.geom.clone();
        // part.geometry.center();
        
        if(model.adjust) {
          const a = model.adjust;
          part.scale.set(a[0], a[1], a[2]);
          part.geometry.translate(a[3], a[4], a[5]);
          part.rotation.set(a[6], a[7], a[8]);
        }
          
        part.material = plasticMaterial;
        return part;
      }
      
      function buildRig() {
        const rig = [];      
        const rows = taElement.value.split('\n');
        rows.forEach(row => {
          rig.push(row.split(','));
        });
        rig.forEach(p => {
          try {
            if(p.length > 8) {
              const part = getPart(p[0]);
              part.scale.set(p[1] * part.scale.x, p[2] * part.scale.y, p[3] * part.scale.z);
              part.position.set(p[4], p[5], p[6]); 
              part.rotation.set(p[7] * (Math.PI / 180), p[8] * (Math.PI / 180), p[9] * (Math.PI / 180)); 
              scene.add(part);
            }
          }
          catch(e) { console.log(e); };
        });
      }      
      
      function setXRay(on) {
        scene.children.forEach(p => {
          if(on) {
            p.material = wireMaterial;
          }
          else {
            p.material = plasticMaterial;
          }
        });
      }
      
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      
      let isDown = false;
      let isDrag = false;
      
      function onPointerMove(event) {
        pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
        
        if(isDown)
          isDrag = true;
        else
          isDrag = false;
      }
      window.addEventListener('pointermove', onPointerMove);
      
      function onPointerUp() {
        isDown = false;
        if(isDrag)
          return;
      }
      window.addEventListener('pointerup', onPointerUp);
      
      function onPointerDown() {
        isDown = true;
      }      
      window.addEventListener('pointerdown', onPointerDown);
                              
      function setSpecProp(name, value) {
        currentSpec[name] = value;
        setScreenSpec(currentSpec);        
        urlParams.set(name, value.toFixed(2));
        window.location.hash = urlParams;
      }
               
      function startLoad() {
        loadingCount++;
        loaderEl.style.display = 'block';
      }
      
      let loaded = false;
      
      function endLoad() {
        loadingCount--;
        if(loadingCount === 0) {
          loaded = true;
          loaderEl.style.display = 'none';
        }
      }

      function setCamera(cam) {
        camera.position.set(...cam.pos);
        controls.target.set(...cam.target);
        controls.update();
        
        gui.updateDisplay();
        document.activeElement.blur();
      }
      
      function animate() {
        renderer.render(scene, camera);
      }
      
      function updateRaycaster() {
        raycaster.setFromCamera(pointer, camera);

        let intersects = [];        
      }
      
      renderer.setAnimationLoop(() => {
        if(loaded)
          updateRaycaster();
        animate();
      });

      window.addEventListener('resize', onWindowResize, false);

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    </script>
  </body>
</html>